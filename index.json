[{"content":"虚析构函数、纯虚函数和抽象类 虚析构函数 基类指针指向了一个new出来的派生类，delete基类指针只会调用基类析构函数，而不会调用派生类构造函数，如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class son{ public: ~son(){ cout \u0026lt;\u0026lt; \u0026#34;son::destructor\u0026#34; \u0026lt;\u0026lt; endl; } }; class grandson:public son{ public: ~grandson(){ cout \u0026lt;\u0026lt; \u0026#34;grandson::destructor\u0026#34; \u0026lt;\u0026lt; endl; } }; int main (){ son* pSon = new grandson; delete pSon; } // 输出 son::destructor 解决方法是将基类析构函数声明为虚函数；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class son{ public: virtual ~son(){ cout \u0026lt;\u0026lt; \u0026#34;son::destructor\u0026#34; \u0026lt;\u0026lt; endl; } }; class grandson:public son{ public: ~grandson(){ cout \u0026lt;\u0026lt; \u0026#34;grandson::destructor\u0026#34; \u0026lt;\u0026lt; endl; } }; int main (){ son* pSon = new grandson; delete pSon; } // grandson::destructor // son::destructor 基类的析构函数声明为虚函数，那么派生类析构函数默认为虚函数；\n一般来说：\n类中定义了虚函数，就应该将析构函数定义为虚函数 类作为基类使用就应该将析构函数作为虚函数（避免通过指针回收new出来的派生类） 纯虚函数：没有函数体的虚函数 1 2 3 4 5 6 7 class son{ public: virtual void get() = 0; // 纯虚函数 virtual void put() { cout \u0026lt;\u0026lt; \u0026#34;put\u0026#34; \u0026lt;\u0026lt; endl; }; }; 纯虚函数没有函数体，不能被调用；定义了纯虚函数的类叫抽象类：\n抽象类只能作为基类来派生出其他类，不能创建对象 抽象类指针以及引用可以指向抽象类派生出来的类的对象 1 2 3 son s; // 错误 son *pson; // 正确 pson = new son; // 错误 通常抽象类的纯虚函数在派生类中实现；只有抽象类的派生类实现了抽象类的所有纯虚函数，派生类才不是一个抽象类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class son{ // 抽象类 public: virtual void get() = 0; // 纯虚函数 virtual void put() { cout \u0026lt;\u0026lt; \u0026#34;put\u0026#34; \u0026lt;\u0026lt; endl; }; }; class grandson:public son{ public: void get (){ cout \u0026lt;\u0026lt; \u0026#34;get\u0026#34; \u0026lt;\u0026lt; endl; } }; int main (){ // grandson g; Variable type \u0026#39;grandson\u0026#39; is an abstract class } 抽象类也可以定义普通的成员函数，成员变量；由派生类对象或者指向派生类对象的抽象类（基类）指针来调用；\n通过指向派生类对象的基类指针来调用：\n基类中定义的成员变量、成员函数 派生类的虚函数 访问的基类成员函数中调用纯虚函数，构成多态；因为此时基类指针指向了派生类对象，说明派生类对象不是抽象类，派生类将基类中的纯虚函数都实现了 所以抽象类的其他成员函数可以调用纯虚函数，因为this指针指向了派生类对象，构成多态；但是构造函数不能调用纯虚函数，应为构造函数调用的虚函数在编译期间确定，是自身的虚函数而不是派生类的，所以构造函数不能调用纯虚函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Base { public: virtual void func(){ cout \u0026lt;\u0026lt; \u0026#34;Base::func() called\u0026#34; \u0026lt;\u0026lt; endl; } virtual void call(){ func(); } }; class Derived:public Base{ public: void func(){ cout \u0026lt;\u0026lt; \u0026#34;Derived::func() called\u0026#34; \u0026lt;\u0026lt; endl; } }; int main (){ Derived d; Base b; Base *pb = \u0026amp;b; // 体现派生对象地址可以给基类对象指针 d.call(); // Derived::func() called 传进函数的this指针指向派生类，构成多态 pb -\u0026gt;call(); // Base::func() called this指针指向基类不构成多态 b.call(); } // 而指向派生对象基类指针不能调用派生类成员函数 可能是因为基类指针不能给派生类指针赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class A{ public: virtual void f() = 0; void get() { this -\u0026gt; f(); // this 指针无论是基类还是派生类指针，都是指向派生类对象的指针 } ~A{ // f() 错误 } }; class B:public A{ public: void f(){ cout \u0026lt;\u0026lt; \u0026#34;B:f()\u0026#34; \u0026lt;\u0026lt; endl; } } int main(){ B b; b.get(); } // B:f() ","permalink":"https://codenotesll.github.io/posts/%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/","summary":"虚析构函数、纯虚函数和抽象类 虚析构函数 基类指针指向了一个new出来的派生类，delete基类指针只会调用基类析构函数，而不会调用派生类构造函数，如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class son{ public: ~son(){ cout \u0026lt;\u0026lt; \u0026#34;son::destructor\u0026#34; \u0026lt;\u0026lt; endl; } }; class grandson:public son{ public: ~grandson(){ cout \u0026lt;\u0026lt; \u0026#34;grandson::destructor\u0026#34; \u0026lt;\u0026lt; endl; } }; int main (){ son* pSon = new grandson; delete pSon; } // 输出 son::destructor 解决方法是将基类析构函数声明为虚函数；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class son{ public: virtual ~son(){ cout \u0026lt;\u0026lt; \u0026#34;son::destructor\u0026#34; \u0026lt;\u0026lt; endl; } }; class grandson:public son{ public: ~grandson(){ cout \u0026lt;\u0026lt; \u0026#34;grandson::destructor\u0026#34; \u0026lt;\u0026lt; endl; } }; int main (){ son* pSon = new grandson; delete pSon; } // grandson::destructor // son::destructor 基类的析构函数声明为虚函数，那么派生类析构函数默认为虚函数；","title":"Biji"},{"content":"second md test\n","permalink":"https://codenotesll.github.io/posts/second/","summary":"second md test","title":"Second"},{"content":"test hugo\n","permalink":"https://codenotesll.github.io/posts/test/","summary":"test hugo","title":"Test"}]